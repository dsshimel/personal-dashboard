/**
 * @fileoverview Daily email digest module.
 *
 * Sends a daily email at 8:00 AM with an AI-generated briefing followed
 * by the raw todo list. The briefing is generated by spawning the Claude
 * CLI with the user's editable prompt + todo data. Uses Resend for email
 * delivery and node-cron for scheduling.
 *
 * Configuration via environment variables:
 *   RESEND_API_KEY   - Resend API key (required for email)
 *   DAILY_EMAIL_TO   - Recipient email address (required for email)
 *   DAILY_EMAIL_FROM - Sender address (optional, defaults to dashboard@resend.dev)
 */

import { Database } from 'bun:sqlite';
import cron from 'node-cron';
import { Resend } from 'resend';
import { getDb } from './db.js';
import { listTodos, type Todo } from './todo.js';
import { listRecitations, type Recitation } from './recitations.js';
import { fetchConfiguredWeather, formatWeatherForPrompt } from './weather.js';
import { fetchUpcomingEvents, type CalendarEvent } from './google-calendar.js';

/** Default briefing prompt used when none is saved. */
const DEFAULT_PROMPT = `You are a personal productivity assistant. Given the following todo list, generate a daily briefing email that:
1. Summarizes the current todos
2. Suggests specific, actionable next steps for each item
3. Prioritizes items that have been on the list the longest
4. Offers encouragement and practical time-management tips

Keep the tone friendly and motivating. Format the output as HTML suitable for an email body (no <html>, <head>, or <body> tags — just content HTML like <p>, <ul>, <strong>, etc).`;

/** Environment-based email configuration. */
interface EmailConfig {
  apiKey: string;
  to: string;
  from: string;
}

/**
 * Initializes the settings table and daily_briefings table.
 *
 * @param db - The SQLite database instance.
 */
export function initDailyEmailDb(db: Database): void {
  db.run(`
    CREATE TABLE IF NOT EXISTS settings (
      key TEXT PRIMARY KEY,
      value TEXT NOT NULL
    )
  `);
  db.run(`
    CREATE TABLE IF NOT EXISTS daily_briefings (
      id TEXT PRIMARY KEY,
      html TEXT NOT NULL,
      prompt TEXT NOT NULL,
      todo_count INTEGER NOT NULL,
      has_weather INTEGER NOT NULL DEFAULT 0,
      has_recitations INTEGER NOT NULL DEFAULT 0,
      has_research INTEGER NOT NULL DEFAULT 0,
      has_calendar INTEGER NOT NULL DEFAULT 0,
      created_at TEXT NOT NULL
    )
  `);

  // Migration: add has_research column if it doesn't exist (for existing databases)
  try {
    db.run('ALTER TABLE daily_briefings ADD COLUMN has_research INTEGER NOT NULL DEFAULT 0');
  } catch {
    // Column already exists
  }

  // Migration: add has_calendar column if it doesn't exist (for existing databases)
  try {
    db.run('ALTER TABLE daily_briefings ADD COLUMN has_calendar INTEGER NOT NULL DEFAULT 0');
  } catch {
    // Column already exists
  }
}

/**
 * Gets the current briefing prompt from the database.
 * Returns the default prompt if none is saved.
 */
export function getBriefingPrompt(): string {
  const db = getDb();
  const row = db.prepare('SELECT value FROM settings WHERE key = ?').get('briefing_prompt') as { value: string } | null;
  return row ? row.value : DEFAULT_PROMPT;
}

/**
 * Saves the briefing prompt to the database.
 *
 * @param prompt - The new prompt text.
 */
export function setBriefingPrompt(prompt: string): void {
  const db = getDb();
  db.prepare(`
    INSERT INTO settings (key, value) VALUES (?, ?)
    ON CONFLICT(key) DO UPDATE SET value = excluded.value
  `).run('briefing_prompt', prompt);
}

/**
 * Reads email config from environment variables.
 *
 * @returns Config object, or null if required vars are missing.
 */
function getEmailConfig(): EmailConfig | null {
  const apiKey = process.env.RESEND_API_KEY;
  const to = process.env.DAILY_EMAIL_TO;
  const from = process.env.DAILY_EMAIL_FROM || 'Dashboard <dashboard@resend.dev>';
  if (!apiKey || !to) return null;
  return { apiKey, to, from };
}

/**
 * Builds an HTML section for the todo list to append to the email.
 */
function buildTodosHtml(todos: Todo[]): string {
  if (todos.length === 0) return '';
  const items = todos.map(todo => {
    const date = new Date(todo.createdAt).toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
    });
    const ageMs = Date.now() - new Date(todo.createdAt).getTime();
    const ageDays = Math.floor(ageMs / (1000 * 60 * 60 * 24));
    const ageLabel = `${ageDays} day${ageDays !== 1 ? 's' : ''} ago`;
    return `<li style="margin-bottom: 6px;">${todo.description} <span style="color: #888; font-size: 12px;">(added ${date}, ${ageLabel})</span></li>`;
  }).join('\n');

  return `
    <hr style="border: none; border-top: 1px solid #ddd; margin: 24px 0;">
    <h3 style="color: #333; margin-bottom: 12px;">TODO List</h3>
    <ul style="color: #444; line-height: 1.6; padding-left: 20px;">${items}</ul>
  `;
}

/**
 * Builds an HTML section for recitations to append to the email.
 */
function buildRecitationsHtml(recitations: Recitation[]): string {
  if (recitations.length === 0) return '';
  const items = recitations.map(r => {
    const content = r.content
      ? `<br><span style="color: #666; font-size: 13px; white-space: pre-wrap;">${r.content}</span>`
      : '';
    return `<li style="margin-bottom: 10px;"><strong>${r.title}</strong>${content}</li>`;
  }).join('\n');

  return `
    <hr style="border: none; border-top: 1px solid #ddd; margin: 24px 0;">
    <h3 style="color: #333; margin-bottom: 12px;">Recitations</h3>
    <ul style="color: #444; line-height: 1.6; padding-left: 20px; list-style: none;">${items}</ul>
  `;
}

/**
 * Builds an HTML section for calendar events to append to the email.
 * Groups events by day with time ranges.
 */
function buildCalendarHtml(events: CalendarEvent[]): string {
  if (events.length === 0) return '';

  const byDay = new Map<string, CalendarEvent[]>();
  for (const event of events) {
    const dateKey = event.allDay ? event.start : event.start.split('T')[0];
    if (!byDay.has(dateKey)) byDay.set(dateKey, []);
    byDay.get(dateKey)!.push(event);
  }

  let html = `
    <hr style="border: none; border-top: 1px solid #ddd; margin: 24px 0;">
    <h3 style="color: #333; margin-bottom: 12px;">Upcoming Events</h3>`;

  for (const [dateKey, dayEvents] of byDay) {
    const label = new Date(dateKey + 'T00:00:00').toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });
    html += `<p style="color: #333; font-weight: 600; margin: 16px 0 6px 0; font-size: 14px;">${label}</p>`;
    html += '<ul style="color: #444; line-height: 1.6; padding-left: 20px; list-style: none; margin: 0;">';
    for (const ev of dayEvents) {
      const time = ev.allDay
        ? '<span style="color: #888;">All day</span>'
        : `<span style="color: #888;">${new Date(ev.start).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })} – ${new Date(ev.end).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })}</span>`;
      const location = ev.location ? `<br><span style="color: #888; font-size: 13px;">${ev.location}</span>` : '';
      html += `<li style="margin-bottom: 8px;">${time} &nbsp; <strong>${ev.summary}</strong>${location}</li>`;
    }
    html += '</ul>';
  }

  return html;
}

/**
 * Spawns the Claude CLI to generate the briefing content.
 * Uses `claude -p` for a one-shot print-mode call with no streaming.
 *
 * @returns The generated text, or null if the CLI call fails.
 */
async function generateBriefingWithClaude(prompt: string, weatherText: string | null): Promise<string | null> {
  let fullPrompt = prompt;
  if (weatherText) {
    fullPrompt += `\n\nHere is the current weather and forecast:\n\n${weatherText}`;
  }
  fullPrompt += `\n\nToday's date is ${new Date().toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' })}.`;

  try {
    const proc = Bun.spawn(['claude', '-p', fullPrompt], {
      stdout: 'pipe',
      stderr: 'pipe',
    });

    const [stdout, stderr, exitCode] = await Promise.all([
      new Response(proc.stdout).text(),
      new Response(proc.stderr).text(),
      proc.exited,
    ]);

    if (exitCode !== 0) {
      console.error(`Claude CLI exited with code ${exitCode}: ${stderr}`);
      return null;
    }

    let output = stdout.trim();
    if (!output) {
      console.error('Claude CLI returned empty output');
      return null;
    }

    // Strip markdown code fences (```html ... ```) that Claude sometimes wraps around HTML output
    output = output.replace(/^```(?:html)?\s*\n?/i, '').replace(/\n?```\s*$/,  '');

    return output;
  } catch (error) {
    console.error('Failed to spawn Claude CLI:', error);
    return null;
  }
}

/**
 * Builds the complete email HTML from an AI briefing and the todo list.
 */
function buildEmailHtml(aiBriefing: string | null, todos: Todo[], calendarEvents: CalendarEvent[], recitations: Recitation[]): string {
  const wrapper = (content: string) => `
    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto;">
      <h2 style="color: #333;">Daily Briefing</h2>
      ${content}
      <p style="color: #999; font-size: 12px; margin-top: 20px;">Sent from your Personal Dashboard</p>
    </div>
  `;

  const briefingSection = aiBriefing
    ? `<div style="color: #444; line-height: 1.6;">${aiBriefing}</div>`
    : '<p style="color: #666;">AI briefing unavailable.</p>';

  const todosSection = buildTodosHtml(todos);
  const calendarSection = buildCalendarHtml(calendarEvents);
  const recitationsSection = buildRecitationsHtml(recitations);

  return wrapper(briefingSection + todosSection + calendarSection + recitationsSection);
}

/** Row shape from the daily_briefings table. */
interface DailyBriefingRow {
  id: string;
  html: string;
  prompt: string;
  todo_count: number;
  has_weather: number;
  has_recitations: number;
  has_research: number;
  has_calendar: number;
  created_at: string;
}

/** A stored daily briefing. */
export interface DailyBriefing {
  id: string;
  html: string;
  prompt: string;
  todoCount: number;
  hasWeather: boolean;
  hasRecitations: boolean;
  hasCalendar: boolean;
  createdAt: string;
}

/** Converts a DailyBriefingRow to a DailyBriefing. */
function rowToBriefing(row: DailyBriefingRow): DailyBriefing {
  return {
    id: row.id,
    html: row.html,
    prompt: row.prompt,
    todoCount: row.todo_count,
    hasWeather: row.has_weather === 1,
    hasRecitations: row.has_recitations === 1,
    hasCalendar: row.has_calendar === 1,
    createdAt: row.created_at,
  };
}

/**
 * Gets the most recent saved briefing from the database.
 * Returns null if no briefing has been generated yet.
 */
export function getLatestBriefing(): DailyBriefing | null {
  const db = getDb();
  const row = db.prepare('SELECT * FROM daily_briefings ORDER BY created_at DESC LIMIT 1').get() as DailyBriefingRow | null;
  if (!row) return null;
  return rowToBriefing(row);
}

/**
 * Lists all saved briefings, most recent first.
 *
 * @param limit - Maximum number of briefings to return (default 20).
 */
export function listBriefings(limit = 20): DailyBriefing[] {
  const db = getDb();
  const rows = db.prepare('SELECT * FROM daily_briefings ORDER BY created_at DESC LIMIT ?').all(limit) as DailyBriefingRow[];
  return rows.map(rowToBriefing);
}

/**
 * Saves a generated briefing to the database.
 */
function saveBriefing(html: string, prompt: string, todoCount: number, hasWeather: boolean, hasRecitations: boolean, hasCalendar: boolean): DailyBriefing {
  const db = getDb();
  const id = crypto.randomUUID();
  const now = new Date().toISOString();
  db.prepare(`
    INSERT INTO daily_briefings (id, html, prompt, todo_count, has_weather, has_recitations, has_calendar, created_at)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
  `).run(id, html, prompt, todoCount, hasWeather ? 1 : 0, hasRecitations ? 1 : 0, hasCalendar ? 1 : 0, now);
  return { id, html, prompt, todoCount, hasWeather, hasRecitations, hasCalendar, createdAt: now };
}

/** Optional callback for reporting progress during briefing generation. */
export type BriefingProgressCallback = (step: string) => void;

/**
 * Generates the daily briefing HTML without sending an email.
 * Saves the result to the daily_briefings table.
 *
 * @param onProgress - Optional callback invoked at each step.
 * @returns The saved DailyBriefing record.
 */
export async function generateBriefingPreview(onProgress?: BriefingProgressCallback): Promise<DailyBriefing> {
  onProgress?.('Loading todos and recitations...');
  const todos = listTodos().filter(t => !t.done);
  const recitations = listRecitations().filter(r => !r.done);
  const prompt = getBriefingPrompt();

  // Fetch weather data (non-fatal if it fails or is unconfigured)
  onProgress?.('Fetching weather data...');
  let weatherText: string | null = null;
  let hasWeather = false;
  try {
    const weather = await fetchConfiguredWeather();
    if (weather) {
      weatherText = formatWeatherForPrompt(weather);
      hasWeather = true;
      onProgress?.(`Weather loaded for ${weather.location.name}`);
    } else {
      onProgress?.('No weather location configured, skipping weather');
    }
  } catch (error) {
    console.error('Failed to fetch weather for briefing:', error);
    onProgress?.('Weather fetch failed, continuing without weather');
  }

  // Fetch calendar events (non-fatal if it fails or Google is not connected)
  onProgress?.('Fetching calendar events...');
  let calendarEvents: CalendarEvent[] = [];
  let hasCalendar = false;
  try {
    calendarEvents = await fetchUpcomingEvents(4);
    if (calendarEvents.length > 0) {
      hasCalendar = true;
      onProgress?.(`Loaded ${calendarEvents.length} calendar event${calendarEvents.length !== 1 ? 's' : ''}`);
    } else {
      onProgress?.('No upcoming calendar events');
    }
  } catch (error) {
    console.error('Failed to fetch calendar events for briefing:', error);
    onProgress?.('Calendar fetch failed, continuing without calendar');
  }

  // Generate AI briefing by spawning Claude CLI
  onProgress?.('Generating briefing with Claude... (this is the slow part)');
  const aiBriefing = await generateBriefingWithClaude(prompt, weatherText);

  onProgress?.('Building email HTML...');
  const html = buildEmailHtml(aiBriefing, todos, calendarEvents, recitations);

  const briefing = saveBriefing(html, prompt, todos.length, hasWeather, recitations.length > 0, hasCalendar);
  onProgress?.('Briefing ready');
  return briefing;
}

/**
 * Sends the daily digest email. Exported for testing and manual triggering.
 */
export async function sendDailyDigest(): Promise<void> {
  const config = getEmailConfig();
  if (!config) {
    console.log('Daily email not configured (missing RESEND_API_KEY or DAILY_EMAIL_TO)');
    return;
  }

  const briefing = await generateBriefingPreview();
  const resend = new Resend(config.apiKey);

  try {
    await resend.emails.send({
      from: config.from,
      to: config.to,
      subject: `Daily Briefing: ${briefing.todoCount} item${briefing.todoCount !== 1 ? 's' : ''} — ${new Date().toLocaleDateString()}`,
      html: briefing.html,
    });
    console.log(`Daily briefing sent to ${config.to} with ${briefing.todoCount} todos`);
  } catch (error) {
    console.error('Failed to send daily briefing:', error);
  }
}

/** Returns whether the daily email scheduler is configured (env vars present). */
export function isEmailSchedulerConfigured(): boolean {
  return getEmailConfig() !== null;
}

/**
 * Starts the daily email cron job. Call once at server startup.
 * No-op if environment variables are not configured.
 */
export function startDailyEmailScheduler(): void {
  const config = getEmailConfig();
  if (!config) {
    console.log('Daily email scheduler not started (missing RESEND_API_KEY or DAILY_EMAIL_TO)');
    return;
  }

  // Run at 8:00 AM every day (server local timezone)
  cron.schedule('0 8 * * *', () => {
    console.log('Running daily email digest...');
    sendDailyDigest();
  });

  console.log('Daily email scheduler started (8:00 AM daily)');
}
