/**
 * @fileoverview Daily email digest module.
 *
 * Sends a daily email at 8:00 AM with an AI-generated briefing followed
 * by the raw todo list. The briefing is generated by spawning the Claude
 * CLI with the user's editable prompt + todo data. Uses Resend for email
 * delivery and node-cron for scheduling.
 *
 * Configuration via environment variables:
 *   RESEND_API_KEY   - Resend API key (required for email)
 *   DAILY_EMAIL_TO   - Recipient email address (required for email)
 *   DAILY_EMAIL_FROM - Sender address (optional, defaults to dashboard@resend.dev)
 */

import { Database } from 'bun:sqlite';
import cron from 'node-cron';
import { Resend } from 'resend';
import { getDb } from './db.js';
import { listTodos, type Todo } from './todo.js';
import { listRecitations, type Recitation } from './recitations.js';
import { fetchConfiguredWeather, formatWeatherForPrompt } from './weather.js';

/** Default briefing prompt used when none is saved. */
const DEFAULT_PROMPT = `You are a personal productivity assistant. Given the following todo list, generate a daily briefing email that:
1. Summarizes the current todos
2. Suggests specific, actionable next steps for each item
3. Prioritizes items that have been on the list the longest
4. Offers encouragement and practical time-management tips

Keep the tone friendly and motivating. Format the output as HTML suitable for an email body (no <html>, <head>, or <body> tags — just content HTML like <p>, <ul>, <strong>, etc).`;

/** Environment-based email configuration. */
interface EmailConfig {
  apiKey: string;
  to: string;
  from: string;
}

/**
 * Initializes the settings table and daily_briefings table.
 *
 * @param db - The SQLite database instance.
 */
export function initDailyEmailDb(db: Database): void {
  db.run(`
    CREATE TABLE IF NOT EXISTS settings (
      key TEXT PRIMARY KEY,
      value TEXT NOT NULL
    )
  `);
  db.run(`
    CREATE TABLE IF NOT EXISTS daily_briefings (
      id TEXT PRIMARY KEY,
      html TEXT NOT NULL,
      prompt TEXT NOT NULL,
      todo_count INTEGER NOT NULL,
      has_weather INTEGER NOT NULL DEFAULT 0,
      has_recitations INTEGER NOT NULL DEFAULT 0,
      created_at TEXT NOT NULL
    )
  `);
}

/**
 * Gets the current briefing prompt from the database.
 * Returns the default prompt if none is saved.
 */
export function getBriefingPrompt(): string {
  const db = getDb();
  const row = db.prepare('SELECT value FROM settings WHERE key = ?').get('briefing_prompt') as { value: string } | null;
  return row ? row.value : DEFAULT_PROMPT;
}

/**
 * Saves the briefing prompt to the database.
 *
 * @param prompt - The new prompt text.
 */
export function setBriefingPrompt(prompt: string): void {
  const db = getDb();
  db.prepare(`
    INSERT INTO settings (key, value) VALUES (?, ?)
    ON CONFLICT(key) DO UPDATE SET value = excluded.value
  `).run('briefing_prompt', prompt);
}

/**
 * Reads email config from environment variables.
 *
 * @returns Config object, or null if required vars are missing.
 */
function getEmailConfig(): EmailConfig | null {
  const apiKey = process.env.RESEND_API_KEY;
  const to = process.env.DAILY_EMAIL_TO;
  const from = process.env.DAILY_EMAIL_FROM || 'Dashboard <dashboard@resend.dev>';
  if (!apiKey || !to) return null;
  return { apiKey, to, from };
}

/** Escapes HTML special characters. */
function escapeHtml(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

/**
 * Formats the todo list as plain text for inclusion in the Claude prompt.
 */
function formatTodosForPrompt(todos: Todo[]): string {
  if (todos.length === 0) return '(No todos on the list)';
  return todos.map((todo, i) => {
    const date = new Date(todo.createdAt).toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
    });
    const ageMs = Date.now() - new Date(todo.createdAt).getTime();
    const ageDays = Math.floor(ageMs / (1000 * 60 * 60 * 24));
    return `${i + 1}. ${todo.description} (added ${date}, ${ageDays} day${ageDays !== 1 ? 's' : ''} ago)`;
  }).join('\n');
}

/**
 * Formats the recitations list as plain text for inclusion in the Claude prompt.
 */
function formatRecitationsForPrompt(recitations: Recitation[]): string {
  if (recitations.length === 0) return '';
  return recitations.map((r, i) => {
    let text = `${i + 1}. ${r.title}`;
    if (r.content) {
      text += `\n${r.content}`;
    }
    return text;
  }).join('\n\n');
}

/**
 * Spawns the Claude CLI to generate the briefing content.
 * Uses `claude -p` for a one-shot print-mode call with no streaming.
 *
 * @returns The generated text, or null if the CLI call fails.
 */
async function generateBriefingWithClaude(prompt: string, todos: Todo[], recitations: Recitation[], weatherText: string | null): Promise<string | null> {
  const todoText = formatTodosForPrompt(todos);
  const recitationText = formatRecitationsForPrompt(recitations);
  let fullPrompt = `${prompt}\n\nHere is my current todo list:\n\n${todoText}`;
  if (weatherText) {
    fullPrompt += `\n\nHere is the current weather and forecast:\n\n${weatherText}`;
  }
  if (recitationText) {
    fullPrompt += `\n\nHere are my daily recitations (include these verbatim in the email):\n\n${recitationText}`;
  }
  fullPrompt += `\n\nToday's date is ${new Date().toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' })}.`;

  try {
    const proc = Bun.spawn(['claude', '-p', fullPrompt], {
      stdout: 'pipe',
      stderr: 'pipe',
    });

    const [stdout, stderr, exitCode] = await Promise.all([
      new Response(proc.stdout).text(),
      new Response(proc.stderr).text(),
      proc.exited,
    ]);

    if (exitCode !== 0) {
      console.error(`Claude CLI exited with code ${exitCode}: ${stderr}`);
      return null;
    }

    const output = stdout.trim();
    if (!output) {
      console.error('Claude CLI returned empty output');
      return null;
    }

    return output;
  } catch (error) {
    console.error('Failed to spawn Claude CLI:', error);
    return null;
  }
}

/**
 * Builds the raw todo list HTML table (appended after the AI briefing).
 */
function buildTodoListHtml(todos: Todo[]): string {
  if (todos.length === 0) return '';

  const todoRows = todos.map(todo => {
    const date = new Date(todo.createdAt).toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
    });
    return `
      <tr>
        <td style="padding: 8px 12px; border-bottom: 1px solid #eee; color: #222;">
          ${escapeHtml(todo.description)}
        </td>
        <td style="padding: 8px 12px; border-bottom: 1px solid #eee; color: #999; font-size: 12px; white-space: nowrap;">
          ${date}
        </td>
      </tr>
    `;
  }).join('');

  return `
    <h3 style="color: #333; margin-top: 24px; border-top: 1px solid #eee; padding-top: 16px;">Full Todo List</h3>
    <table style="width: 100%; border-collapse: collapse;">
      ${todoRows}
    </table>
  `;
}

/**
 * Builds the recitations HTML section for the email.
 * Each recitation is rendered verbatim with its title and content.
 */
function buildRecitationsHtml(recitations: Recitation[]): string {
  if (recitations.length === 0) return '';

  const items = recitations.map(r => {
    const contentHtml = r.content
      ? `<div style="margin: 4px 0 0 0; white-space: pre-wrap; color: #444;">${escapeHtml(r.content)}</div>`
      : '';
    return `
      <div style="margin-bottom: 16px; padding: 12px; background: #f9f9f9; border-left: 3px solid #667; border-radius: 4px;">
        <strong style="color: #222;">${escapeHtml(r.title)}</strong>
        ${contentHtml}
      </div>
    `;
  }).join('');

  return `
    <h3 style="color: #333; margin-top: 24px; border-top: 1px solid #eee; padding-top: 16px;">Daily Recitations</h3>
    ${items}
  `;
}

/**
 * Builds the complete email HTML from an AI briefing and the todo list.
 */
function buildEmailHtml(aiBriefing: string | null, todos: Todo[], recitations: Recitation[]): string {
  const wrapper = (content: string) => `
    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto;">
      <h2 style="color: #333;">Daily Briefing</h2>
      ${content}
      <p style="color: #999; font-size: 12px; margin-top: 20px;">Sent from your Personal Dashboard</p>
    </div>
  `;

  if (todos.length === 0) {
    return wrapper(aiBriefing || '<p style="color: #666;">No todos on your list. Enjoy your day!</p>');
  }

  const briefingSection = aiBriefing
    ? `<div style="color: #444; line-height: 1.6;">${aiBriefing}</div>`
    : '<p style="color: #666;">AI briefing unavailable. Here are your current todos:</p>';

  const todoSection = buildTodoListHtml(todos);
  const recitationSection = buildRecitationsHtml(recitations);

  return wrapper(briefingSection + todoSection + recitationSection);
}

/** Row shape from the daily_briefings table. */
interface DailyBriefingRow {
  id: string;
  html: string;
  prompt: string;
  todo_count: number;
  has_weather: number;
  has_recitations: number;
  created_at: string;
}

/** A stored daily briefing. */
export interface DailyBriefing {
  id: string;
  html: string;
  prompt: string;
  todoCount: number;
  hasWeather: boolean;
  hasRecitations: boolean;
  createdAt: string;
}

/** Converts a DailyBriefingRow to a DailyBriefing. */
function rowToBriefing(row: DailyBriefingRow): DailyBriefing {
  return {
    id: row.id,
    html: row.html,
    prompt: row.prompt,
    todoCount: row.todo_count,
    hasWeather: row.has_weather === 1,
    hasRecitations: row.has_recitations === 1,
    createdAt: row.created_at,
  };
}

/**
 * Gets the most recent saved briefing from the database.
 * Returns null if no briefing has been generated yet.
 */
export function getLatestBriefing(): DailyBriefing | null {
  const db = getDb();
  const row = db.prepare('SELECT * FROM daily_briefings ORDER BY created_at DESC LIMIT 1').get() as DailyBriefingRow | null;
  if (!row) return null;
  return rowToBriefing(row);
}

/**
 * Lists all saved briefings, most recent first.
 *
 * @param limit - Maximum number of briefings to return (default 20).
 */
export function listBriefings(limit = 20): DailyBriefing[] {
  const db = getDb();
  const rows = db.prepare('SELECT * FROM daily_briefings ORDER BY created_at DESC LIMIT ?').all(limit) as DailyBriefingRow[];
  return rows.map(rowToBriefing);
}

/**
 * Saves a generated briefing to the database.
 */
function saveBriefing(html: string, prompt: string, todoCount: number, hasWeather: boolean, hasRecitations: boolean): DailyBriefing {
  const db = getDb();
  const id = crypto.randomUUID();
  const now = new Date().toISOString();
  db.prepare(`
    INSERT INTO daily_briefings (id, html, prompt, todo_count, has_weather, has_recitations, created_at)
    VALUES (?, ?, ?, ?, ?, ?, ?)
  `).run(id, html, prompt, todoCount, hasWeather ? 1 : 0, hasRecitations ? 1 : 0, now);
  return { id, html, prompt, todoCount, hasWeather, hasRecitations, createdAt: now };
}

/** Optional callback for reporting progress during briefing generation. */
export type BriefingProgressCallback = (step: string) => void;

/**
 * Generates the daily briefing HTML without sending an email.
 * Saves the result to the daily_briefings table.
 *
 * @param onProgress - Optional callback invoked at each step.
 * @returns The saved DailyBriefing record.
 */
export async function generateBriefingPreview(onProgress?: BriefingProgressCallback): Promise<DailyBriefing> {
  onProgress?.('Loading todos and recitations...');
  const todos = listTodos().filter(t => !t.done);
  const recitations = listRecitations();
  const prompt = getBriefingPrompt();

  // Fetch weather data (non-fatal if it fails or is unconfigured)
  onProgress?.('Fetching weather data...');
  let weatherText: string | null = null;
  let hasWeather = false;
  try {
    const weather = await fetchConfiguredWeather();
    if (weather) {
      weatherText = formatWeatherForPrompt(weather);
      hasWeather = true;
      onProgress?.(`Weather loaded for ${weather.location.name}`);
    } else {
      onProgress?.('No weather location configured, skipping weather');
    }
  } catch (error) {
    console.error('Failed to fetch weather for briefing:', error);
    onProgress?.('Weather fetch failed, continuing without weather');
  }

  // Generate AI briefing by spawning Claude CLI
  onProgress?.('Generating briefing with Claude... (this is the slow part)');
  const aiBriefing = await generateBriefingWithClaude(prompt, todos, recitations, weatherText);

  onProgress?.('Building email HTML...');
  const html = buildEmailHtml(aiBriefing, todos, recitations);

  const briefing = saveBriefing(html, prompt, todos.length, hasWeather, recitations.length > 0);
  onProgress?.('Briefing ready');
  return briefing;
}

/**
 * Sends the daily digest email. Exported for testing and manual triggering.
 */
export async function sendDailyDigest(): Promise<void> {
  const config = getEmailConfig();
  if (!config) {
    console.log('Daily email not configured (missing RESEND_API_KEY or DAILY_EMAIL_TO)');
    return;
  }

  const briefing = await generateBriefingPreview();
  const resend = new Resend(config.apiKey);

  try {
    await resend.emails.send({
      from: config.from,
      to: config.to,
      subject: `Daily Briefing: ${briefing.todoCount} item${briefing.todoCount !== 1 ? 's' : ''} — ${new Date().toLocaleDateString()}`,
      html: briefing.html,
    });
    console.log(`Daily briefing sent to ${config.to} with ${briefing.todoCount} todos`);
  } catch (error) {
    console.error('Failed to send daily briefing:', error);
  }
}

/**
 * Starts the daily email cron job. Call once at server startup.
 * No-op if environment variables are not configured.
 */
export function startDailyEmailScheduler(): void {
  const config = getEmailConfig();
  if (!config) {
    console.log('Daily email scheduler not started (missing RESEND_API_KEY or DAILY_EMAIL_TO)');
    return;
  }

  // Run at 8:00 AM every day (server local timezone)
  cron.schedule('0 8 * * *', () => {
    console.log('Running daily email digest...');
    sendDailyDigest();
  });

  console.log('Daily email scheduler started (8:00 AM daily)');
}
